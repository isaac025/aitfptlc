{-# LANGUAGE BlockArguments #-}

module RAA where

import Prelude hiding (succ, pred)
import CBI
import LC

rec f = selfApplication f $$ selfApplication f

-- add x y = if (iszero y) then x else add (succ x) (pred y)


-- Exercise 4.1
-- sum1 f n = if iszero n then zero else add n (f (pred n))
-- sum = rec sum1
-- sum three
-- = rec sum1 three
-- = sum1 sum1 three
-- => add three (sum1 (pred three)), evaluate pred three to two
-- = add three (add two (sum1 (pred two))), evaluate pred three to one
-- = add three (add two (add one (sum1 (pred one)))), evaluate pred three to zero
-- = add three (add two (add one zero)), evaluate add one zero to one
-- = add three (add two one), evaluate add one two to three
-- = add three three, evaluate to six
-- = six

-- Exercise 4.2
-- let mult x y = if iszero y then zero else rec add x (mult x (pred y))
--     sub x y = if iszero y then x else rec sub (pred x) (pred y) 
--     absDiff x y = add (sub x y) (sub y x)
--     equal x y = iszero (absDiff x y)
--
-- prod1 f n = if equal n one then one else mult n (f (pred n))
-- prod = rec prod1
-- prod three
-- = rec prod1 three
-- = prod1 prod1 three
-- => mult three (prod1 (pred three)), evaluate three to two
-- => mult three (mult two (prod1 (pred two))), evaluate two to one
-- => mult three (mult two one)
-- => mult three (add two (mult two (pred one))), evaluate one to zero
-- => mult three (add two zero)
-- => mult three two
-- => add three (mult three one)
-- => add three (add three (mult three zero))
-- => add three (add three zero)
-- => add three three
-- => add (succ three) (pred three)
-- => add (succ four) (pred two)
-- => add (succ five) (pred one)
-- => add six zero
-- => six
  
-- Exercise 4.3
-- funSum1 f fun n = if iszero n then fun zero else add (fun n) (funSum1 f fun (pred n))
-- double x = add x x
-- funSum = rec funSum1
-- funSum double three
-- => add (double three) (funSum1 double two)
-- => add (double three) (add (double two) (funSum1 double one))
-- => add (double three) (add (double two) (add (double one) (funSum1 double zero)))
-- => add (double three) (add (double two) (add (double one) (double zero)))
-- => add (double three) (add (double two) (add (add one one) (add zero zero)))
-- => add (double three) (add (double two) (add two zero))
-- => add (double three) (add (double two) two)
-- => add (double three) (add (add two two) two)
-- => add (double three) (add (add three one) two)
-- => add (double three) (add (add four zero) two)
-- => add (double three) (add four two)
-- => add (double three) (add five one)
-- => add (double three) (add six zero)
-- => add (double three) six
-- => add (add three three) six
-- => add (add four two) six
-- => add (add five one) six
-- => add (add six zero) six
-- => add six six
-- => add seven five
-- => add eight four
-- => add nine three
-- => add ten two
-- => add eleven one
-- => add twelve zero
-- => twelve

-- Exercise 4.4
-- funSumStep1 f fun n s = if iszero n then fun zero else add (fun n) (funSumStep1 f fun (sub n s) s)
-- funSumStep = rec funSumSte
-- (a) funSumStep double five two
-- => add (double five) (funSumStep1 double (sub five two) two)
-- => add (double five) (funSumStep1 double (sub four one) two)
-- => add (double five) (funSumStep1 double (sub three zero) two)
-- => add (double five) (funSumStep1 double three two)
-- => add (double five) (add (double three) (funSumStep1 double (sub three two) two))
-- => add (double five) (add (double three) (funSumStep1 double (sub two one) two))
-- => add (double five) (add (double three) (funSumStep1 double (sub one zero) two))
-- => add (double five) (add (double three) (funSumStep1 double one two))
-- => add (double five) (add (double three) (add (double one) (funSumStep1 double (sub one two) two)))
-- => add (double five) (add (double three) (add (double one) (funSumStep1 double (sub zero one) two)))
-- => add (double five) (add (double three) (add (double one) (funSumStep1 double zero two)))
-- => add (double five) (add (double three) (add (double one) (double zero)))
-- => add (double five) (add (double three) (add (double one) (add zero zero)))
-- => add (double five) (add (double three) (add (double one) zero))
-- => add (double five) (add (double three) (add (add one one) zero))
-- => add (double five) (add (double three) (add (add two zero) zero))
-- => add (double five) (add (double three) (add two zero))
-- => add (double five) (add (double three) two)
-- => add (double five) (add (add three three) two)
-- => add (double five) (add (add four two) two)
-- => add (double five) (add (add five one) two)
-- => add (double five) (add (add six zero) two)
-- => add (double five) (add six two)
-- => add (double five) (add seven one)
-- => add (double five) (add eight zero)
-- => add (double five) eight
-- => add (add five five) eight
-- ...
-- => add ten eight
-- ...
-- => eighteen
-- 
-- (b) funSumStep double four two
-- => add (double four) (funSumStep1 double (sub four two) two)
-- => add (double four) (funSumStep1 double (sub three one) two)
-- => add (double four) (funSumStep1 double (sub two zero) two)
-- => add (double four) (funSumStep1 double two two)
-- => add (double four) (add (double two) (funSumStep1 double (sub two two) two))
-- => add (double four) (add (double two) (funSumStep1 double (sub one one) two))
-- => add (double four) (add (double two) (funSumStep1 double zero two))
-- => add (double four) (add (double two) (add double zero))
-- ...
-- => add (double four) (add four zero)
-- => add (double four) four
-- ...
-- => add eight four
-- ...
-- => twelve

-- Exercise 4.5
-- greater x y = not (iszero (sub x y))
-- less x y = if equal x y then false else not greater x y
-- (a) less three two
-- => not (not (iszero (sub three two)))
-- => not (not (iszero one))
-- => not (not false)
-- => not true
-- => false
-- (b) less two three
-- => not (not (iszero (sub two three)))
-- => not (not (iszero zero))
-- => not (not true)
-- => not false
-- => true
-- (c) less two two
-- => equal two two 
-- => true
--
-- lessOrEqual = if equal x y then true else not greater x y
-- (d) lessOrEqual three two
-- => not (not (iszero (sub three two)))
-- => not (not (iszero one))
-- => not (not false)
-- => not true
-- => false
-- (e) lessOrEqual two three
-- => not (not (iszero (sub two three)))
-- => not (not (iszero zero))
-- => not (not true)
-- => not false
-- => true
-- (f) lessOrEqual two two
-- => equal two two 
-- => true

-- Exercise 4.6
-- mod x y = if zero y then x else mod1 x y
-- mod1 x y = if less x y then x else mod1 (sub x y) y
-- (a) mod three two
-- => mod1 three two
-- => mod1 (sub three two) three
-- => mod1 one three
-- => one
-- (b) mod two three
-- => mod1 two three
-- => two
-- (c) mod three zero
-- => three
